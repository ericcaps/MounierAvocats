/**
 * Minified by jsDelivr using Terser v5.15.1.
 * Original file: /npm/uikit@3.16.12/src/js/util/position.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{css}from"./style";import{within}from"./filter";import{offset}from"./dimensions";import{clamp,isArray,ucfirst}from"./lang";import{offsetViewport,overflowParents}from"./viewport";const dirs=[["width","x","left","right"],["height","y","top","bottom"]];export function positionAt(t,e,o){o={attach:{element:["left","top"],target:["left","top"],...o.attach},offset:[0,0],placement:[],...o},isArray(e)||(e=[e,e]),offset(t,getPosition(t,e,o))}function getPosition(t,e,o){const r=attachTo(t,e,o),{boundary:i,viewportOffset:n=0,placement:f}=o;let s=r;for(const[c,[a,,l,p]]of Object.entries(dirs)){const u=getViewport(t,e[c],n,i,c);if(isWithin(r,u,c))continue;let m=0;if("flip"===f[c]){const i=o.attach.target[c];if(i===p&&r[p]<=u[p]||i===l&&r[l]>=u[l])continue;m=flip(t,e,o,c)[l]-r[l];const f=getScrollArea(t,e[c],n,c);if(!isWithin(applyOffset(r,m,c),f,c)){if(isWithin(r,f,c))continue;if(o.recursion)return!1;const i=flipAxis(t,e,o);if(i&&isWithin(i,f,1-c))return i;continue}}else if("shift"===f[c]){const t=offset(e[c]),{offset:i}=o;m=clamp(clamp(r[l],u[l],u[p]-r[a]),t[l]-r[a]+i[c],t[p]-i[c])-r[l]}s=applyOffset(s,m,c)}return s}function attachTo(t,e,o){let{attach:r,offset:i}={attach:{element:["left","top"],target:["left","top"],...o.attach},offset:[0,0],...o},n=offset(t);for(const[t,[o,,f,s]]of Object.entries(dirs)){const c=r.target[t]===r.element[t]?offsetViewport(e[t]):offset(e[t]);n=applyOffset(n,c[f]-n[f]+moveBy(r.target[t],s,c[o])-moveBy(r.element[t],s,n[o])+ +i[t],t)}return n}function applyOffset(t,e,o){const[,r,i,n]=dirs[o],f={...t};return f[i]=t[r]=t[i]+e,f[n]+=e,f}function moveBy(t,e,o){return"center"===t?o/2:t===e?o:0}function getViewport(t,e,o,r,i){let n=getIntersectionArea(...commonScrollParents(t,e).map(offsetViewport));return o&&(n[dirs[i][2]]+=o,n[dirs[i][3]]-=o),r&&(n=getIntersectionArea(n,offset(isArray(r)?r[i]:r))),n}function getScrollArea(t,e,o,r){const[i,n,f,s]=dirs[r],[c]=commonScrollParents(t,e),a=offsetViewport(c);return["auto","scroll"].includes(css(c,`overflow-${n}`))&&(a[f]-=c[`scroll${ucfirst(f)}`],a[s]=a[f]+c[`scroll${ucfirst(i)}`]),a[f]+=o,a[s]-=o,a}function commonScrollParents(t,e){return overflowParents(e).filter((e=>within(t,e)))}function getIntersectionArea(...t){let e={};for(const o of t)for(const[,,t,r]of dirs)e[t]=Math.max(e[t]||0,o[t]),e[r]=Math.min(...[e[r],o[r]].filter(Boolean));return e}function isWithin(t,e,o){const[,,r,i]=dirs[o];return t[r]>=e[r]&&t[i]<=e[i]}function flip(t,e,{offset:o,attach:r},i){return attachTo(t,e,{attach:{element:flipAttach(r.element,i),target:flipAttach(r.target,i)},offset:flipOffset(o,i)})}function flipAxis(t,e,o){return getPosition(t,e,{...o,attach:{element:o.attach.element.map(flipAttachAxis).reverse(),target:o.attach.target.map(flipAttachAxis).reverse()},offset:o.offset.reverse(),placement:o.placement.reverse(),recursion:!0})}function flipAttach(t,e){const o=[...t],r=dirs[e].indexOf(t[e]);return~r&&(o[e]=dirs[e][1-r%2+2]),o}function flipAttachAxis(t){for(let e=0;e<dirs.length;e++){const o=dirs[e].indexOf(t);if(~o)return dirs[1-e][o%2+2]}}function flipOffset(t,e){return(t=[...t])[e]*=-1,t}
//# sourceMappingURL=/sm/27e7dfb8fa75c3cc92b6df5ede7255fc85a8f81c5f54e227dfbcb65de650c022.map